# tq のテスト
## 単体テスト
### コンバート
bash conv-check.script
- with WL
  cd DimensionDefinitionLanguage; bash conv-test.script; cd ../
- without WL
  逆コンバーター
  cd DimensionDefinitionLanguage; bash conv2-test.script; cd ../

### エスケープ処理
#### クオーティング
bash tq-escape.test

### compile: クオーティング
echo '#12$`$134()' | ./tq.o in=/dev/stdin -FT  -Pin -C -Fst
echo '$`$134()' | ./tq.o in=/dev/stdin -FT  -Pin -C -Fst
echo '#12$``$134()' | ./tq.o in=/dev/stdin -FT  -Pin -C -Fst
echo '$``$134()' | ./tq.o in=/dev/stdin -FT  -Pin -C -Fst
echo '$``$' | ./tq.o in=/dev/stdin -FT  -Pin -C -Fst
./tq.o in=test_compile.t -C -FT -Pin    
 => $~List(List(List,List,List,List))
echo '$``List' | ./tq.o in=/dev/stdin -FT -C -Pin   
 => "List"
echo '$``List($4)' | ./tq.o in=/dev/stdin -FT -C -Pin   
 => "List($4)"

### compile: アンパック
./tq.o in=test_unpack.t -FT -Pin -C
 => $($1,$2,List,$1,$2)

### compile: リテラル化
./tq.o in=test_riteraltree.t -FT -Pin -C
./tq.o in=test_ritelal-unpack.t -FT -Pin -C

### 次元取得
- リーフノードのみ取得される:
./tq.o in=test_dim.ddf -Pin -Fst data=vals.csv -FT

### データバインド
-
./tq.o in=test.ddf -FT out=test.ddl data=test.csv -Pin -Pout
- 配列指定のあるリーフノードにバインドされる
./tq.o in=test_bind.t  data=test.csv -FT -Pin
 => $TOP($X$List($LEAF,$LEAF[]@(Length),$LEAF[2]@(Weight,mm)),$X$List[2]($LEAF[2]@(kg,1,2,322)))

### レファレンス
#### 木
./tq.o in=test_ref-tree.ddf -Pin -FT
#### セルフ
./tq.o in=test_ref.1.t -FMa -FT -Fh -Pin
- 完全グラフ
./tq.o in=test_ref-graph.4.t -Pin -FT -FMa
 => #1$1($#2@#2$2($#1@#1$1,$#3@#3$3,$#4@#4$4),#3$3($#1@#1$1,$#2@#2$2,$#4@#4$4),#4$4($#1@#1$1,#2$2,$#3@#3$3))
====multiline====>
[0],1,,,,5,,,,9,,11,,
0,[1->11],2,3,4,5,,,,9,,,,
,,[2->0],,,,,,,,,,,
,,,[3->5],,,,,,,,,,
,,,,[4->9],,,,,,,,,
0,,,,,[5],6,7,8,9,,11,,
,,,,,,[6->0],,,,,,,
,,,,,,,[7->11],,,,,,
,,,,,,,,[8->9],,,,,
0,,,,,5,,,,[9],10,11,12,
,,,,,,,,,,[10->0],,,
,,,,,,,,,,,[11],,
,,,,,,,,,,,,[12->5],

#### セルフ+ output
./tq.o in=test_ref.1.t out=test_ref.1.ot -FMa -FT -Fh -Pin -Pout

#### セルフ+ output + data    
- フラットパターン    
./tq.o in=test_ref.2.t out=test_ref.2.ot -FT -Pin -Pout data=test.csv
- 入れ子パターン
./tq.o in=test_ref.2.t out=test_ref.2-1.ot -FT -Pin -Pout data=test.csv
- out形式で参照をリストの入れ子に
./tq.o in=test_ref.2.t out=test_refR.2.ot -FT -Pin -Pout data=test.csv
- 再帰レファレンス($#9)
./tq.o in=test_ref.1.t out=test_ref.1.ot -FT -Pin -Pout data=test.csv
 => $#0@#0$0($#1@#1$1[5]@(322,4,5,68,7)($#0@#0$0,$#2@#2$2),$#2@#2$2($#1@#1$1[5]@(322,4,5,68,7),$#0@#0$0,$#9@#9$#2[3]@#2$2@(Length,Weight,mm,kg,1,2)))
- 複合レファレンス
./tq.o in=test_ref.3.ddf data=test.csv -FT -Pin
 => $TOP(#1$1[2](#2$2[2]@(Length,Weight,mm,kg)),$#2[3]@@#2$2[2]@(Length,Weight,mm,kg)(1,2,322))
- 複合レファレンス(2)
./tq.o out=test_complex-ref.ddl -Pout -FT in=test_complex-ref.ddf data=test.csv

### 内積
./tq.o in=test_prd.1.ddf out=test_prd.1.ddl data=test.csv -FT -Pprod  -C
./tq.o in=test_prd.1.ddf out=test_prd.2.ddl data=test.csv -FT -Pprod  -C
./tq.o in=test_prd.1.ddf out=test_prd.3.ddl data=test.csv -FT -Pprod  -C
./tq.o in=test_prd.1.ddf out=test_prd.3.ddl data=test.csv -FT -Pprod  -C  | ./tq.o in=/dev/stdin Sp=0,0 -Pin -FT
./tq.o in=test_prd.1.ddf out=test_prd.4.ddl data=test.csv -FT -Pprod  -C
./tq.o in=test_prd.1.ddf out=test_prd.5.ddl data=test.csv -FT -Pprod  -C
./tq.o in=test_prd.1.ddf out=test_prd.5.ddl data=test.csv -FT -Pprod  -C | ./tq.o in=/dev/stdin Sp=0,1 -Pin -FT
- Headのディストリビュート(未完)
./tq.o in=test_prd.2.ddf out=test_prd.2-1.ddl -Pprod -Pin -FT
./tq.o in=test_prd.2.ddf out=test_prd.2-1.ddl -Pprod -Pin -FT data=vals.csv
TODO: @(1,2) を$PI$の時にディストリビュート-> Headをvalstr化する

### サーチ
- ポジション指定
./tq.o in=test.t Sp=0,1 -FT -Pin


## パフォーマンス
### 大型の頭部
TODO
### 1.2億ノード
- 坂本さん、パフォーマンスはこれと比べてください。
time ./tq.o in=lllarge-single-test.t buff=30
124653854 Nodes were operated.
real    0m41.343s
user    0m29.955s
sys     0m11.371s
@ 26G mem
-
time ./tq.o in=lllarge-single-test.t buff=30 -FJ -Pin > lllarge-single-test.json
124653854 Nodes were operated.
real    1m21.795s
user    1m4.612s
sys     0m16.943s
@ 29G mem
-
time cat lllarge-single-test.json | jq . > /dev/null
real    2m25.157s
user    2m5.473s
sys     0m20.885s
@ 36G mem
### 4.9億ノード
time ./tq.o in=lllarge4-single-test.t -FT
498615417 Nodes were operated.
real    3m28.752s
user    2m28.315s
sys     1m0.389s
@ 96G mem
### 大型配列のバインド 1.6G => 1.2G(4億データポイント)
-
time ./tq.o in=large-test_bind.t -FT data=large-test.csv data_buff=2000000000 
4 Nodes were operated.
real    0m14.931s
user    0m14.010s
sys     0m0.920s
@ 1.2G mem
-
time ./tq.o in=large-test_bind.t -FT -Pin data=large-test.csv data_buff=2000000000 | ./tq.o in=/dev/stdin
4 Nodes were operated.
400000004 Nodes were operated.
real    2m37.815s
user    1m51.709s
sys     0m49.234s
@ 86G mem



